name: Build and Deploy to EC2

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  DOCKER_BUILDKIT: 1

jobs:
  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest

    steps:
      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts

      - name: Pull Latest Code
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'ENDSSH'
            set -e

            PROJECT_DIR=~/SWTS_Website

            if [ ! -d "$PROJECT_DIR" ]; then
              echo "Cloning repository..."
              git clone https://x-access-token:${{ secrets.GH_PAT }}@github.com/${{ vars.GH_ORG }}/${{ vars.GH_REPO }}.git "$PROJECT_DIR"
            else
              cd "$PROJECT_DIR"
              git remote set-url origin https://x-access-token:${{ secrets.GH_PAT }}@github.com/${{ vars.GH_ORG }}/${{ vars.GH_REPO }}.git
              git fetch origin
              git reset --hard origin/main
              git clean -fd
            fi
          ENDSSH

      - name: Deploy Application
        env:
          DEPLOY_DOMAIN: ${{ vars.DOMAIN }}
          NGINX_CONTAINER: ${{ vars.SHARED_NGINX_CONTAINER || 'logs_nginx' }}
          PROJECT_CONFIG: ${{ vars.NGINX_CONFIG_NAME || 'swts.conf' }}
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << ENDSSH
            set -e
            cd ~/SWTS_Website

            # Determine docker command
            if groups | grep -q docker; then
              DOCKER_CMD="docker"
            else
              DOCKER_CMD="sudo docker"
            fi

            # Deployment lock to prevent conflicts with other projects
            LOCK_FILE="/tmp/shared_nginx_deploy.lock"
            LOCK_TIMEOUT=300

            acquire_lock() {
              echo "Acquiring deployment lock..."
              WAIT_TIME=0
              while [ -f "\$LOCK_FILE" ]; do
                if [ -f "\$LOCK_FILE" ]; then
                  LOCK_AGE=\$(($(date +%s) - $(stat -c %Y "\$LOCK_FILE" 2>/dev/null || echo 0)))
                  if [ \$LOCK_AGE -gt 600 ]; then
                    echo "Removing stale lock (age: \${LOCK_AGE}s)"
                    rm -f "\$LOCK_FILE"
                    break
                  fi
                fi
                if [ \$WAIT_TIME -ge \$LOCK_TIMEOUT ]; then
                  echo "ERROR: Timeout waiting for deployment lock"
                  exit 1
                fi
                echo "Another deployment in progress. Waiting... (\${WAIT_TIME}s)"
                sleep 10
                WAIT_TIME=\$((WAIT_TIME + 10))
              done
              echo "SWTS_Website:\$(date +%s)" > "\$LOCK_FILE"
              echo "Lock acquired."
            }

            release_lock() {
              rm -f "\$LOCK_FILE"
              echo "Lock released."
            }

            trap release_lock EXIT
            acquire_lock

            echo "=========================================="
            echo "Deploying SWTS_Website"
            echo "Domain: $DEPLOY_DOMAIN"
            echo "=========================================="

            # Update domain in nginx config
            sed -i "s/server_name .*/server_name $DEPLOY_DOMAIN;/" nginx/conf.d/$PROJECT_CONFIG

            # Stop old containers and force remove any conflicting ones
            echo "Stopping existing containers..."
            \$DOCKER_CMD compose -f docker-compose.shared.yml down --remove-orphans || true

            # Force remove containers if they still exist (handles naming conflicts)
            echo "Cleaning up any leftover containers..."
            \$DOCKER_CMD rm -f swts_app swts_certbot 2>/dev/null || true

            # Build and start
            echo "Building..."
            \$DOCKER_CMD compose -f docker-compose.shared.yml build --no-cache

            echo "Starting..."
            \$DOCKER_CMD compose -f docker-compose.shared.yml up -d

            echo "Waiting for app to be healthy..."
            sleep 15

            # Update nginx config (only if changed, to avoid affecting other projects)
            echo "Updating nginx configuration..."
            NGINX_CONTAINER="$NGINX_CONTAINER"

            if \$DOCKER_CMD container inspect \$NGINX_CONTAINER >/dev/null 2>&1; then
              # Check if config has changed before copying and reloading
              LOCAL_HASH=\$(md5sum nginx/conf.d/$PROJECT_CONFIG | cut -d' ' -f1)
              REMOTE_HASH=\$(\$DOCKER_CMD exec \$NGINX_CONTAINER cat /etc/nginx/conf.d/$PROJECT_CONFIG 2>/dev/null | md5sum | cut -d' ' -f1 || echo "none")

              if [ "\$LOCAL_HASH" = "\$REMOTE_HASH" ]; then
                echo "Nginx config unchanged. Skipping reload."
              else
                echo "Config changed. Updating..."
                \$DOCKER_CMD cp nginx/conf.d/$PROJECT_CONFIG \$NGINX_CONTAINER:/etc/nginx/conf.d/$PROJECT_CONFIG

                echo "Testing nginx config..."
                \$DOCKER_CMD exec \$NGINX_CONTAINER nginx -t

                echo "Reloading nginx..."
                \$DOCKER_CMD exec \$NGINX_CONTAINER nginx -s reload

                echo "Nginx reloaded successfully!"
              fi
            else
              echo "ERROR: Shared nginx container not found!"
              echo "Make sure the first project (ubuntu-docker-logs-finder) is deployed."
              exit 1
            fi

            echo "Deployment complete!"
          ENDSSH

      - name: Setup SSL (Optional)
        env:
          DEPLOY_DOMAIN: ${{ vars.DOMAIN }}
          SSL_EMAIL: ${{ vars.SSL_EMAIL || 'admin@example.com' }}
          NGINX_CONTAINER: ${{ vars.SHARED_NGINX_CONTAINER || 'logs_nginx' }}
          PROJECT_CONFIG: ${{ vars.NGINX_CONFIG_NAME || 'swts.conf' }}
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << ENDSSH
            set -e
            cd ~/SWTS_Website

            if groups | grep -q docker; then
              DOCKER_CMD="docker"
            else
              DOCKER_CMD="sudo docker"
            fi

            CERT_PATH="/home/ubuntu/ubuntu-docker-logs-finder/certbot/conf/live/$DEPLOY_DOMAIN"

            # Check if certificate already exists
            if [ -d "\$CERT_PATH" ]; then
              echo "SSL certificate already exists for $DEPLOY_DOMAIN"
            else
              echo "Obtaining SSL certificate for $DEPLOY_DOMAIN..."

              # Use docker run directly to avoid entrypoint override issues
              \$DOCKER_CMD run --rm \
                -v /home/ubuntu/ubuntu-docker-logs-finder/certbot/www:/var/www/certbot \
                -v /home/ubuntu/ubuntu-docker-logs-finder/certbot/conf:/etc/letsencrypt \
                --network shared_proxy_network \
                certbot/certbot certonly \
                --webroot \
                --webroot-path=/var/www/certbot \
                --email "$SSL_EMAIL" \
                --agree-tos \
                --no-eff-email \
                --non-interactive \
                -d "$DEPLOY_DOMAIN"

              echo "Certificate obtained!"
            fi
          ENDSSH

      - name: Verify Deployment
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'ENDSSH'
            cd ~/SWTS_Website

            if groups | grep -q docker; then
              DOCKER_CMD="docker"
            else
              DOCKER_CMD="sudo docker"
            fi

            # Check containers
            echo "Container status:"
            $DOCKER_CMD compose -f docker-compose.shared.yml ps

            # Health check via Docker network
            sleep 3
            if $DOCKER_CMD exec swts_app wget --no-verbose --tries=1 --spider http://127.0.0.1:5002/ 2>/dev/null; then
              echo "Health check passed!"
            else
              echo "Warning: Health check on swts_app:5002 failed"
              $DOCKER_CMD compose -f docker-compose.shared.yml logs --tail=20
            fi
          ENDSSH
